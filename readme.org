#+STARTUP: overview
#+STARTUP: content
#+STARTUP: showall
#+STARTUP: showeverything
#+TITLE: GO First

이 내용은 주로 디스커버리 Go의 내용입니다. 레디북에 있으니 참고 하세요.

https://ridibooks.com/v2/Detail?id=443000367&_s=search&_q=go

* Go 설치하기

** Ubuntu/Debian Install
   #+BEGIN_EXAMPLE
   sudo apt-get install golang
   #+END_EXAMPLE

** CentOS/Redhat
   #+BEGIN_EXAMPLE
   sudo yum install golang
   #+END_EXAMPLE

** Window
  Install File Downloads: https://golang.org/dl/ 

** GO ROOT Setup
** Default Setting

*** Linux Path
#+BEGIN_EXAMPLE
/usr/local/go 
#+END_EXAMPLE

*** Windows Path 
#+BEGIN_EXAMPLE
C:\Go
#+END_EXAMPLE

*** Custome Path Setting
#+BEGIN_EXAMPLE
export GOROOT=$HOME/go
#+END_EXAMPLE

*** Check Setting
#+BEGIN_EXAMPLE
  go env
#+END_EXAMPLE

* Go Package 

Go 에서는 특정 Maven 이나 Pip 처럼  레파지토리는 가지고 있지 않으며 라이브러리의 저장된 원격 저장소를 지정하여 패키지를 설치 할수 있다.


#+BEGIN_EXAMPLE
 go install buffer
 GOPATH/pkg/<os>

#+END_EXAMPLE

* Go Test

*** Test File
#+BEGIN_EXAMPLE
  [FileName]_test.go
#+END_EXAMPLE

*** Test Func
#+BEGIN_EXAMPLE

  Example[functionName](){
  }
#+END_EXAMPLE

* Go String & Data Struct

** String
   []byte 와 string 은 거의 동일하지만 string의 경우 읽기 전용
   []byte 를 사용할 경우 통신 프로그램에서 처리 하기 좋을것 같다. 

** 문자열 연결

#+NAME: String Format
#+BEGIN_SRC
s := 'abc'
ps := &s
s += "def" //문자열 연결 

s = fmt.Sprint(s,"def") // 문자열이 아닌 변수와도 연결하여 문자열 생성
s = fmt.Sprintf("%sdef",s)  
s = strings.Join([]string{s,"def"},"") // 구분자를 연결할 경우 좋은 방법 (포멧 데이터 생성)
fmt.Println(s)
fmt.Println(*ps)
#+END_SRC

** String to Number
문자열을 숫자로 변경하거나 숫자를 문자열로 변환 하는 방법

#+NAME: StrToInt

#+BEGIN_SRC

	var i int
	var k int64
	var f float64
	var s string
	var err error

	i, err = strconv.Atoi("350")                  // i == 350
	k, err = strconv.ParseInt("cc7fdd", 16, 32) // k == 13402077
	k, err = strconv.ParseInt("0xcc7fdd", 0, 32)  // k == 13402077
	f, err = strconv.ParseFloat("3.14", 64)    // f == 3.14
	s = strconv.Itoa(340)                     // s == "340"
	s = strconv.FormatInt(13402077, 16)      // s == "cc7fdd"

#+END_SRC

** Array and Slice
배열보다는 유연한 구조의 슬라이스의 사용해도 된다. 
배열은 길이가 변할수 없고 슬라이스는 길이가 변할수 있는 배열이라고 할수 있다. 
선언 방식이 명시적이지 않아서 좀 느낌이 좋지는 않네요 

*** 변수 선언 
#+BEGIN_SRC
// Array
fruits := [3]string{"사과","바나나","토마토"}

// Slice 
var fruits []string
fruits := make([]string, n)

#+END_SRC

*** 상수
#+BEGIN_SRC

const limit = 100

const max = 1024 * 1024

const (
    RED = 0
    ORANGE = 1
    YELLOW = 2
)

#+END_SRC

*** enumeration
열거형 상수 
iota : 상수 값을 1씩 증가 시킨다. 

#+BEGIN_SRC

const (
    RED = iota //0
    ORANGE     //1
    YELLOW     //2
)
const (
    _ = iota //ignore
    KB ByteSize = 1 << (10 * iota) //1024
    MB          = 1048576
    GB          = 1073741824
    TB          = 1099511627776 
)


#+END_SRC

*** Slicing

#+BEGIN_SRC
	nums := []int{1, 2, 3, 4, 5}
	fmt.Println(nums)
	fmt.Println(nums[0:3])
	fmt.Println(nums[1:])
	fmt.Println(nums[:3])
#+END_SRC

*** Slice Copy
Copy 문법은 값의 개수가 적은 쪽에 맞추서 복사 하게 됩니다. 
그부분 때문에 아래와 같은 코드를 사용해야 하는 경우가 있습니다.

#+BEGIN_SRC
    src := []int(30,20,50,10,40)
    dest := make([]int, len(src))
    copy(dest, sr)c
#+END_SRC


*** Map
순서가 없으며 해시 테이블로 구현된 자료구조 

#+BEGIN_SRC
var m map[keyType]valueType
    m := make(map[keyType]valueType) // 맵 초기화 
    m := map[keyType]valueType{} //빈맵으로 초기화
    value, ok := m[key] //key 가 m에 emfdjdlTdmaus ok가 true 값을 반환
    map[key] = vlaue
#+END_SRC

맵에서 값만을 추출 하고 싶은경우 

#+BEGIN_SRC

for _, v := range m {
// v를 사용
}

#+END_SRC

*** Set
Go 에서는 직접 Set 자료구조를 제공하지 않고 Map 을 사용하여 구현 할수 있다. 

#+BEGIN_SRC
// map 을 set 처럼사용하기 
func hasDupeRune(s string) bool {
	runeSet := map[rune]struct{}{}
	
	for _, r := range s {
		if _, exists := runeSet[r]; exists{
			return true
		}
	runeSet[r] = struct{}{}
	}
	return false
}

#+END_SRC


*** 파일 입출력

#+BEGIN_SRC


f, err := os.Open(filename)
if err != nil {
    return err
}

defer f.Close()
var num int

if _, err := fmt.Fscanf(f,"%d\n",&num); err == nil {
//  파일 데이터 처리 
}

//==========================================
	f, err := os.Create(filename)
	if err != nil {
		return err // 에러 처리 
	}
	defer f.Close()
	var num int

	if _, err := fmt.Fscanf(f,"%d\n",&num); err == nil {
		return err
	//  파일 데이터 처리 
	}

#+END_SRC

** 함수 
- func 정의되며 반환값을 마지막에 정의 한다. 
- 가변 인자: 마지막 매개변수 타입앞에 생략부호(...) 표기하면 여러개의 값을 배열로 받는다.
- 반환값: Go 에서는 하나 이상의 값을 반환 할수 있으며 하나일 경우 괄호는 생략되며 2개 이상일 경우 괄호로 묶어 준다. 
- _ (blank identifier):go의 경우 사용하지 않는 변수에 대해서 컴파일 에러가 발생 하기 때문에 값을 두개 이상 반환하는 함수를 사용할때 반환 값 중 하나만 필요 할 경우 해당 식별자를 사용한다. 이전에 사용했어도 식별자는 재사용 가능
- 값의 반환 : Go의 경우 Call by Value 가 기본으로사용되며 포인터(* 연산자)를 통해서 Call by reference 를 사용할 수 있다. 
- defer 키워드는 함수가 종료 되기 전까지 특정 구문을 지연 시켰다가 함수가 종료 되기 직전에 구문을 수행한다. Java의 finally 와 같은 개념이다. 

*** 내장함수
- close: 채널을 닫을 때 사용
- len: 문자열, 배열, 슬라이스 , 맵 체널의 요소 개수 확인 
- cap: 배열,슬라이스, 채널의 최대 용량 확인(3장 데이터 타입에서 설명)
- new: 구조체를 위한 메모리 생성할때 사용 
- make: 참조 타입(슬라이스,맵,체널)을 위한 메모리 생성시 사용
- copy: 배열 또는 슬라이스 복사
- append: 슬라이스에 요소 추가(3장 데이터 타입에서 설명)
- panic, recover: 에러 처리에 사용
- complex, real imag: 복소수 처리에 사용 


*** 클로저(익명 함수)
- 클로저는 선언될 때 현재 범위에 있는 변수의 값을 캡처하고 호출될 때 캡쳐한 값을 사용한다. 클로저가 호출될 때 캡처한 값을 사용한다. 클로저가 호출될 때 내부에서 사용하는 변수를 접근 할수 없더라도 선언 시점을 기준으로 해당 변수를 사용
- go 에서는 기본 라이브러리 에서도 함수를 매개 변수로 전달하는것은 흔하다. 

** 패키지 
- 소문자로 생성
- 소스 파일 하나로 구성된 페키지는 패키지 이름과 소스 파일 이름을 같게 한다.
- 패키지를 호출하고 사용하지 않으면 에러가 발생(_ 식별자를 앞에 써주면 컴파일 가능)
- 패키지 호출시 init() 함수가 먼저 호출 되고 메인에서 호출한 패키지가 있는 경우 호출된 패키지의 init 함수가 호출 된다. 

*** 다른 숫자 형간의 계산
- 서로 다른 숫자 형 계산은 오류 꼭 타입을 변환 해줘야 함 

*** 문자열 조합
문자열은 +,+= 를 이용해서 조합할수 있으나 문자열 조합시 새로운 문자열을 생성하기 때문에 효율적이지 못하다 대신 strings.join() 함수를 사용하거나 bytes.Buffer 타입을 사용 하는것이 효율적이다.

*** 포인터와 참조 타입
Go는 C와 C++ 처럼 포인터 사용을 허용 하여 메모리 주소에 직접 접근 가능
하지만 주소 값 연산을 허용하지는 않음
포인터 변수가 가진 주소 값을 직접 변경할 수는 없다.
포인터 변수는 타입 앞에 * 연산자를 표기하여 선언

**** 포인터 생성
벼눗 앞에 주소 연산자(&)로 특정 값의 메모리 주소를 포인터 변수에 할당
new() 함수로 메모리를 초기화한 후 포인터 변수에 할당 

#+BEGIN_SRC go-lang
p := new(int)
*p = 1
fmt.Println(p) //주소
fmt.Println(*p) //값

#+END_SRC


#+BEGIN_SRC go-lang
type rect struct{w,h float64}

r := new(rect)
r.w,r.h = 3, 4
fmt.Println(r) // &{3,4}
fmt.Println(*r) //{3,4}
#+END_SRC

**** Go 값 전달 
Go 는 함수 호출시 매개 변수 값을 복사헤서 함수에 전달 한다. 
함수의 매개 변수 값을 변경할 수 없다. 
Go 의 배열은 값을 복사해서 함수나 매서드 내부로 전달하며 큰 배열을 함수나 메서드로 전달하면 시스템의 부담을 준다. 대신 슬라이스를 사용하는 것이 좋다. 슬라이스로 전달시 참조가 전달 됨 
구조체의 경우도 값 전체를 복사하기 때문에 시스템의 부담이 준다 그렇때는 구조체 값을 전달 하지 말고 포인터로 전달하여 부담을 줄일 수 있다. 
