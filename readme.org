#+STARTUP: overview
#+STARTUP: content
#+STARTUP: showall
#+STARTUP: showeverything
#+TITLE: GO First

이 내용은 주로 디스커버리 Go의 내용입니다. 레디북에 있으니 참고 하세요.

https://ridibooks.com/v2/Detail?id=443000367&_s=search&_q=go

* Go 설치하기

** Ubuntu/Debian Install
   #+BEGIN_EXAMPLE
   sudo apt-get install golang
   #+END_EXAMPLE

** CentOS/Redhat
   #+BEGIN_EXAMPLE
   sudo yum install golang
   #+END_EXAMPLE

** Window
  Install File Downloads: https://golang.org/dl/ 

** GO ROOT Setup
** Default Setting

*** Linux Path
#+BEGIN_EXAMPLE
/usr/local/go 
#+END_EXAMPLE

*** Windows Path 
#+BEGIN_EXAMPLE
C:\Go
#+END_EXAMPLE

*** Custome Path Setting
#+BEGIN_EXAMPLE
export GOROOT=$HOME/go
#+END_EXAMPLE

*** Check Setting
#+BEGIN_EXAMPLE
  go env
#+END_EXAMPLE

* Go Test

*** Test File
#+BEGIN_EXAMPLE
  [FileName]_test.go
#+END_EXAMPLE

*** Test Func
#+BEGIN_EXAMPLE

  Example[functionName](){
  }
#+END_EXAMPLE

* Go String & Data Struct

** String
   []byte 와 string 은 거의 동일하지만 string의 경우 읽기 전용
   []byte 를 사용할 경우 통신 프로그램에서 처리 하기 좋을것 같다. 

** 문자열 연결

#+NAME: String Format
#+BEGIN_SRC
s := 'abc'
ps := &s
s += "def" //문자열 연결 

s = fmt.Sprint(s,"def") // 문자열이 아닌 변수와도 연결하여 문자열 생성
s = fmt.Sprintf("%sdef",s)  
s = strings.Join([]string{s,"def"},"") // 구분자를 연결할 경우 좋은 방법 (포멧 데이터 생성)
fmt.Println(s)
fmt.Println(*ps)
#+END_SRC

** String to Number
문자열을 숫자로 변경하거나 숫자를 문자열로 변환 하는 방법

#+NAME: StrToInt

#+BEGIN_SRC

	var i int
	var k int64
	var f float64
	var s string
	var err error

	i, err = strconv.Atoi("350")                  // i == 350
	k, err = strconv.ParseInt("cc7fdd", 16, 32) // k == 13402077
	k, err = strconv.ParseInt("0xcc7fdd", 0, 32)  // k == 13402077
	f, err = strconv.ParseFloat("3.14", 64)    // f == 3.14
	s = strconv.Itoa(340)                     // s == "340"
	s = strconv.FormatInt(13402077, 16)      // s == "cc7fdd"

#+END_SRC

** Array and Slice
배열보다는 유연한 구조의 슬라이스의 사용해도 된다. 
배열은 길이가 변할수 없고 슬라이스는 길이가 변할수 있는 배열이라고 할수 있다. 
선언 방식이 명시적이지 않아서 좀 느낌이 좋지는 않네요 

*** 선언 
#+BEGIN_SRC
// Array
fruits := [3]string{"사과","바나나","토마토"}

// Slice 
var fruits []string
fruits := make([]string, n)

#+END_SRC

*** Slicing

#+BEGIN_SRC
	nums := []int{1, 2, 3, 4, 5}
	fmt.Println(nums)
	fmt.Println(nums[0:3])
	fmt.Println(nums[1:])
	fmt.Println(nums[:3])
#+END_SRC

*** Slice Copy
Copy 문법은 값의 개수가 적은 쪽에 맞추서 복사 하게 됩니다. 
그부분 때문에 아래와 같은 코드를 사용해야 하는 경우가 있습니다.

#+BEGIN_SRC
    src := []int(30,20,50,10,40)
    dest := make([]int, len(src))
    copy(dest, sr)c
#+END_SRC


*** Map
순서가 없으며 해시 테이블로 구현된 자료구조 

#+BEGIN_SRC
var m map[keyType]valueType
    m := make(map[keyType]valueType) // 맵 초기화 
    m := map[keyType]valueType{} //빈맵으로 초기화
    value, ok := m[key] //key 가 m에 emfdjdlTdmaus ok가 true 값을 반환
    map[key] = vlaue
#+END_SRC

맵에서 값만을 추출 하고 싶은경우 

#+BEGIN_SRC

for _, v := range m {
// v를 사용
}

#+END_SRC

*** Set
Go 에서는 직접 Set 자료구조를 제공하지 않고 Map 을 사용하여 구현 할수 있다. 

#+BEGIN_SRC
// map 을 set 처럼사용하기 
func hasDupeRune(s string) bool {
	runeSet := map[rune]struct{}{}
	
	for _, r := range s {
		if _, exists := runeSet[r]; exists{
			return true
		}
	runeSet[r] = struct{}{}
	}
	return false
}

#+END_SRC





